<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Welcome to ETLion Trade’s documentation! &#8212; ETLion Trade 2.0 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />

  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">

  <div class="section" id="welcome-to-etlion-trade-s-documentation">
<h1>Welcome to ETLion Trade&#8217;s documentation!<a class="headerlink" href="#welcome-to-etlion-trade-s-documentation" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<p><strong>Flask-SocketIO</strong> gives Flask applications access to low latency
bi-directional communications between the clients and the server. The
client-side application can use any of the <a class="reference external" href="http://socket.io">SocketIO</a>
official clients libraries in Javascript, C++, Java and Swift, or any
compatible client to establish a permanent connection to the server.</p>
<div class="section" id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<p>You can install this package in the usual way using <code class="docutils literal"><span class="pre">pip</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="n">flask</span><span class="o">-</span><span class="n">socketio</span>
</pre></div>
</div>
</div>
<div class="section" id="requirements">
<h2>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h2>
<p>Flask-SocketIO is compatible with both Python 2.7 and Python 3.3+. The
asynchronous services that this package relies on can be selected among three
choices:</p>
<ul class="simple">
<li><a class="reference external" href="http://eventlet.net/">eventlet</a> is the best performant option, with
support for long-polling and WebSocket transports.</li>
<li><a class="reference external" href="http://www.gevent.org/">gevent</a> is supported in a number of different
configurations. The long-polling transport is fully supported with the
gevent package, but unlike eventlet, gevent does not have native WebSocket
support. To add support for WebSocket there are currently two options. The
<a class="reference external" href="https://pypi.python.org/pypi/gevent-websocket/">gevent-websocket</a>
package adds WebSocket support to gevent, but unfortunately this package is
current only available for Python 2. The other alternative is to use the
<a class="reference external" href="https://uwsgi-docs.readthedocs.io/en/latest/">uWSGI</a> web server, which
comes with WebSocket functionality. The use of gevent is also a performant
option, but slightly lower than eventlet.</li>
<li>The Flask development server based on Werkzeug can be used as well, with the
caveat that it lacks the performance of the other two options, so it should
only be used to simplify the development workflow. This option only supports
the long-polling transport.</li>
</ul>
<p>The extension automatically detects which asynchronous framework to use based
on what is installed. Preference is given to eventlet, followed by gevent.
For WebSocket support in gevent, uWSGI is preferred, followed by
gevent-websocket. If neither eventlet nor gevent are installed, then the Flask
development server is used.</p>
<p>If using multiple processes, a message queue service is used by the processes
to coordinate operations such as broadcasting. The supported queues are
<a class="reference external" href="http://redis.io/">Redis</a>, <a class="reference external" href="https://www.rabbitmq.com/">RabbitMQ</a>, and any
other message queues supported by the
<a class="reference external" href="http://kombu.readthedocs.org/en/latest/">Kombu</a> package.</p>
<p>On the client-side, the official Socket.IO Javascript client library can be
used to establish a connection to the server. There are also official clients
written in Swift, Java and C++. Unofficial clients may also work, as long as
they implement the
<a class="reference external" href="https://github.com/socketio/socket.io-protocol">Socket.IO protocol</a>.</p>
</div>
<div class="section" id="initialization">
<h2>Initialization<a class="headerlink" href="#initialization" title="Permalink to this headline">¶</a></h2>
<p>The following code example shows how to add Flask-SocketIO to a Flask
application:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">render_template</span>
<span class="kn">from</span> <span class="nn">flask_socketio</span> <span class="k">import</span> <span class="n">SocketIO</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;SECRET_KEY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;secret!&#39;</span>
<span class="n">socketio</span> <span class="o">=</span> <span class="n">SocketIO</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">socketio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">init_app()</span></code> style of initialization is also supported. Note the way the
web server is started. The <code class="docutils literal"><span class="pre">socketio.run()</span></code> function encapsulates the start
up of the web server and replaces the <code class="docutils literal"><span class="pre">app.run()</span></code> standard Flask
development server start up. When the application is in debug mode the
Werkzeug development server is still used and configured properly inside
<code class="docutils literal"><span class="pre">socketio.run()</span></code>. In production mode the eventlet web server is used if
available, else the gevent web server is used. If eventlet and gevent are not
installed, the Werkzeug development web server is used.</p>
<p>The command line interface based on click introduced in Flask 0.11 is also
supported. This extension provides a new version of the  <code class="docutils literal"><span class="pre">flask</span> <span class="pre">run</span></code> command
that is appropriate for starting the Socket.IO server. Example usage:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ FLASK_APP=my_app.py flask run
</pre></div>
</div>
<p>The application must serve a page to the client that loads the Socket.IO
library and establishes a connection:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">script</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;text/javascript&quot;</span> <span class="n">src</span><span class="o">=</span><span class="s2">&quot;//cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.6/socket.io.min.js&quot;</span><span class="o">&gt;&lt;/</span><span class="n">script</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">script</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;text/javascript&quot;</span> <span class="n">charset</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="o">&gt;</span>
    <span class="n">var</span> <span class="n">socket</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;http://&#39;</span> <span class="o">+</span> <span class="n">document</span><span class="o">.</span><span class="n">domain</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="n">location</span><span class="o">.</span><span class="n">port</span><span class="p">);</span>
    <span class="n">socket</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="s1">&#39;connect&#39;</span><span class="p">,</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">socket</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="s1">&#39;my event&#39;</span><span class="p">,</span> <span class="p">{</span><span class="n">data</span><span class="p">:</span> <span class="s1">&#39;I</span><span class="se">\&#39;</span><span class="s1">m connected!&#39;</span><span class="p">});</span>
    <span class="p">});</span>
<span class="o">&lt;/</span><span class="n">script</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="receiving-messages">
<h2>Receiving Messages<a class="headerlink" href="#receiving-messages" title="Permalink to this headline">¶</a></h2>
<p>When using SocketIO, messages are received by both parties as events. On the
client side Javascript callbacks are used. With Flask-SocketIO the server
needs to register handlers for these events, similarly to how routes are
handled by view functions.</p>
<p>The following example creates a server-side event handler for an unnamed
event:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@socketio</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="s1">&#39;message&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">handle_message</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;received message: &#39;</span> <span class="o">+</span> <span class="n">message</span><span class="p">)</span>
</pre></div>
</div>
<p>The above example uses string messages. Another type of unnamed events use
JSON data:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@socketio</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="s1">&#39;json&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">handle_json</span><span class="p">(</span><span class="n">json</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;received json: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">json</span><span class="p">))</span>
</pre></div>
</div>
<p>The most flexible type of event uses custom event names. The message data for
these events can be string, bytes, int, or JSON:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@socketio</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="s1">&#39;my event&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">handle_my_custom_event</span><span class="p">(</span><span class="n">json</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;received json: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">json</span><span class="p">))</span>
</pre></div>
</div>
<p>Custom named events can also support multiple arguments:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@socketio</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="s1">&#39;my event&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">handle_my_custom_event</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;received args: &#39;</span> <span class="o">+</span> <span class="n">arg1</span> <span class="o">+</span> <span class="n">arg2</span> <span class="o">+</span> <span class="n">arg3</span><span class="p">)</span>
</pre></div>
</div>
<p>Named events are the most flexible, as they eliminate the need to include
additional metadata to describe the message type.</p>
<p>Flask-SocketIO also supports SocketIO namespaces, which allow the client to
multiplex several independent connections on the same physical socket:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@socketio</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="s1">&#39;my event&#39;</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="s1">&#39;/test&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">handle_my_custom_namespace_event</span><span class="p">(</span><span class="n">json</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;received json: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">json</span><span class="p">))</span>
</pre></div>
</div>
<p>When a namespace is not specified a default global namespace with the name
<code class="docutils literal"><span class="pre">'/'</span></code> is used.</p>
<p>For cases when a decorator syntax isn&#8217;t convenient, the <code class="docutils literal"><span class="pre">on_event</span></code> method
can be used:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_function_handler</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">socketio</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s1">&#39;my event&#39;</span><span class="p">,</span> <span class="n">my_function_handler</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="s1">&#39;/test&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Clients may request an acknowledgement callback that confirms receipt of a
message. Any values returned from the handler function will be passed to the
client as arguments in the callback function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@socketio</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="s1">&#39;my event&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">handle_my_custom_event</span><span class="p">(</span><span class="n">json</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;received json: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">json</span><span class="p">))</span>
    <span class="k">return</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="mi">2</span>
</pre></div>
</div>
<p>In the above example, the client callback function will be invoked with
two arguments, <code class="docutils literal"><span class="pre">'one'</span></code> and <code class="docutils literal"><span class="pre">2</span></code>. If a handler function does not return any
vallues, the client callback function will be invoked without arguments.</p>
</div>
<div class="section" id="sending-messages">
<h2>Sending Messages<a class="headerlink" href="#sending-messages" title="Permalink to this headline">¶</a></h2>
<p>SocketIO event handlers defined as shown in the previous section can send
reply messages to the connected client using the <code class="docutils literal"><span class="pre">send()</span></code> and <code class="docutils literal"><span class="pre">emit()</span></code>
functions.</p>
<p>The following examples bounce received events back to the client that sent
them:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask_socketio</span> <span class="k">import</span> <span class="n">send</span><span class="p">,</span> <span class="n">emit</span>

<span class="nd">@socketio</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="s1">&#39;message&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">handle_message</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="n">send</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="nd">@socketio</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="s1">&#39;json&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">handle_json</span><span class="p">(</span><span class="n">json</span><span class="p">):</span>
    <span class="n">send</span><span class="p">(</span><span class="n">json</span><span class="p">,</span> <span class="n">json</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="nd">@socketio</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="s1">&#39;my event&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">handle_my_custom_event</span><span class="p">(</span><span class="n">json</span><span class="p">):</span>
    <span class="n">emit</span><span class="p">(</span><span class="s1">&#39;my response&#39;</span><span class="p">,</span> <span class="n">json</span><span class="p">)</span>
</pre></div>
</div>
<p>Note how <code class="docutils literal"><span class="pre">send()</span></code> and <code class="docutils literal"><span class="pre">emit()</span></code> are used for unnamed and named events
respectively.</p>
<p>When working with namespaces, <code class="docutils literal"><span class="pre">send()</span></code> and <code class="docutils literal"><span class="pre">emit()</span></code> use the namespace of
the incoming message by default. A different namespace can be specified with
the optional <code class="docutils literal"><span class="pre">namespace</span></code> argument:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@socketio</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="s1">&#39;message&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">handle_message</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="n">send</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="s1">&#39;/chat&#39;</span><span class="p">)</span>

<span class="nd">@socketio</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="s1">&#39;my event&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">handle_my_custom_event</span><span class="p">(</span><span class="n">json</span><span class="p">):</span>
    <span class="n">emit</span><span class="p">(</span><span class="s1">&#39;my response&#39;</span><span class="p">,</span> <span class="n">json</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="s1">&#39;/chat&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>To send an event with multiple arguments, send a tuple:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@socketio</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="s1">&#39;my event&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">handle_my_custom_event</span><span class="p">(</span><span class="n">json</span><span class="p">):</span>
    <span class="n">emit</span><span class="p">(</span><span class="s1">&#39;my response&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="n">json</span><span class="p">),</span> <span class="n">namespace</span><span class="o">=</span><span class="s1">&#39;/chat&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>SocketIO supports acknowledgement callbacks that confirm that a message was
received by the client:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">ack</span><span class="p">():</span>
    <span class="nb">print</span> <span class="s1">&#39;message was received!&#39;</span>

<span class="nd">@socketio</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="s1">&#39;my event&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">handle_my_custom_event</span><span class="p">(</span><span class="n">json</span><span class="p">):</span>
    <span class="n">emit</span><span class="p">(</span><span class="s1">&#39;my response&#39;</span><span class="p">,</span> <span class="n">json</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">ack</span><span class="p">)</span>
</pre></div>
</div>
<p>When using callbacks the Javascript client receives a callback function to
invoke upon receipt of the message. After the client application invokes the
callback function the server invokes the corresponding server-side callback.
If the client-side callback returns any values, these are provided as
arguments to the server-side callback.</p>
<p>The client application can also request an acknoledgement callback for an
event sent to the server. If the server wants to provide arguments for this
callback, it must return them from the event handler function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@socketio</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="s1">&#39;my event&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">handle_my_custom_event</span><span class="p">(</span><span class="n">json</span><span class="p">):</span>
    <span class="c1"># ... handle the event</span>

    <span class="k">return</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="mi">123</span>  <span class="c1"># client callback will receive these 3 arguments</span>
</pre></div>
</div>
</div>
<div class="section" id="broadcasting">
<h2>Broadcasting<a class="headerlink" href="#broadcasting" title="Permalink to this headline">¶</a></h2>
<p>Another very useful feature of SocketIO is the broadcasting of messages.
Flask-SocketIO supports this feature with the <code class="docutils literal"><span class="pre">broadcast=True</span></code> optional
argument to <code class="docutils literal"><span class="pre">send()</span></code> and <code class="docutils literal"><span class="pre">emit()</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@socketio</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="s1">&#39;my event&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">handle_my_custom_event</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">emit</span><span class="p">(</span><span class="s1">&#39;my response&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">broadcast</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>When a message is sent with the broadcast option enabled, all clients
connected to the namespace receive it, including the sender. When namespaces
are not used, the clients connected to the global namespace receive the
message. Note that callbacks are not invoked for broadcast messages.</p>
<p>In all the examples shown until this point the server responds to an event
sent by the client. But for some applications, the server needs to be the
originator of a message. This can be useful to send notifications to clients
of events that originated in the server, for example in a background thread.
The <code class="docutils literal"><span class="pre">socketio.send()</span></code> and <code class="docutils literal"><span class="pre">socketio.emit()</span></code> methods can be used to
broadcast to all connected clients:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">some_function</span><span class="p">():</span>
    <span class="n">socketio</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="s1">&#39;some event&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="mi">42</span><span class="p">})</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal"><span class="pre">socketio.send()</span></code> and <code class="docutils literal"><span class="pre">socketio.emit()</span></code> are not the same
functions as the context-aware <code class="docutils literal"><span class="pre">send()</span></code> and <code class="docutils literal"><span class="pre">emit()</span></code>. Also note that in the
above usage there is no client context, so <code class="docutils literal"><span class="pre">broadcast=True</span></code> is assumed and
does not need to be specified.</p>
</div>
<div class="section" id="rooms">
<h2>Rooms<a class="headerlink" href="#rooms" title="Permalink to this headline">¶</a></h2>
<p>For many applications it is necessary to group users into subsets that can be
addressed together. The best example is a chat application with multiple rooms,
where users receive messages from the room or rooms they are in, but not from
other rooms where other users are. Flask-SocketIO supports this concept of
rooms through the <code class="docutils literal"><span class="pre">join_room()</span></code> and <code class="docutils literal"><span class="pre">leave_room()</span></code> functions:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask_socketio</span> <span class="k">import</span> <span class="n">join_room</span><span class="p">,</span> <span class="n">leave_room</span>

<span class="nd">@socketio</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="s1">&#39;join&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">on_join</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">]</span>
    <span class="n">room</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;room&#39;</span><span class="p">]</span>
    <span class="n">join_room</span><span class="p">(</span><span class="n">room</span><span class="p">)</span>
    <span class="n">send</span><span class="p">(</span><span class="n">username</span> <span class="o">+</span> <span class="s1">&#39; has entered the room.&#39;</span><span class="p">,</span> <span class="n">room</span><span class="o">=</span><span class="n">room</span><span class="p">)</span>

<span class="nd">@socketio</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="s1">&#39;leave&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">on_leave</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">]</span>
    <span class="n">room</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;room&#39;</span><span class="p">]</span>
    <span class="n">leave_room</span><span class="p">(</span><span class="n">room</span><span class="p">)</span>
    <span class="n">send</span><span class="p">(</span><span class="n">username</span> <span class="o">+</span> <span class="s1">&#39; has left the room.&#39;</span><span class="p">,</span> <span class="n">room</span><span class="o">=</span><span class="n">room</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">send()</span></code> and <code class="docutils literal"><span class="pre">emit()</span></code> functions accept an optional <code class="docutils literal"><span class="pre">room</span></code> argument
that cause the message to be sent to all the clients that are in the given
room.</p>
<p>All clients are assigned a room when they connect, named with the session ID
of the connection, which can be obtained from <code class="docutils literal"><span class="pre">request.sid</span></code>. A given client
can join any rooms, which can be given any names. When a client disconnects it
is removed from all the rooms it was in. The context-free <code class="docutils literal"><span class="pre">socketio.send()</span></code>
and <code class="docutils literal"><span class="pre">socketio.emit()</span></code> functions also accept a <code class="docutils literal"><span class="pre">room</span></code> argument to broadcast
to all clients in a room.</p>
<p>Since all clients are assigned a personal room, to address a message to a
single client, the session ID of the client can be used as the room argument.</p>
</div>
<div class="section" id="connection-events">
<h2>Connection Events<a class="headerlink" href="#connection-events" title="Permalink to this headline">¶</a></h2>
<p>Flask-SocketIO also dispatches connection and disconnection events. The
following example shows how to register handlers for them:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@socketio</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="s1">&#39;connect&#39;</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="s1">&#39;/chat&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">test_connect</span><span class="p">():</span>
    <span class="n">emit</span><span class="p">(</span><span class="s1">&#39;my response&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;Connected&#39;</span><span class="p">})</span>

<span class="nd">@socketio</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="s1">&#39;disconnect&#39;</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="s1">&#39;/chat&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">test_disconnect</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Client disconnected&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The connection event handler can optionally return <code class="docutils literal"><span class="pre">False</span></code> to reject the
connection. This is so that the client can be authenticated at this point.</p>
<p>Note that connection and disconnection events are sent individually on each
namespace used.</p>
</div>
<div class="section" id="class-based-namespaces">
<h2>Class-Based Namespaces<a class="headerlink" href="#class-based-namespaces" title="Permalink to this headline">¶</a></h2>
<p>As an alternative to the decorator-based event handlers described above, the
event handlers that belong to a namespace can be created as methods of a
class. The <code class="xref py py-class docutils literal"><span class="pre">flask_socketio.Namespace</span></code> is provided as a base class to
create class-based namespaces:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask_socketio</span> <span class="k">import</span> <span class="n">Namespace</span><span class="p">,</span> <span class="n">emit</span>

<span class="k">class</span> <span class="nc">MyCustomNamespace</span><span class="p">(</span><span class="n">Namespace</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">on_connect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">on_disconnect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">on_my_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">emit</span><span class="p">(</span><span class="s1">&#39;my_response&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="n">socketio</span><span class="o">.</span><span class="n">on_namespace</span><span class="p">(</span><span class="n">MyCustomNamespace</span><span class="p">(</span><span class="s1">&#39;/test&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>When class-based namespaces are used, any events received by the server are
dispatched to a method named as the event name with the <code class="docutils literal"><span class="pre">on_</span></code> prefix. For
example, event <code class="docutils literal"><span class="pre">my_event</span></code> will be handled by a method named <code class="docutils literal"><span class="pre">on_my_event</span></code>.
If an event is received for which there is no corresponding method defined in
the namespace class, then the event is ignored. All event names used in
class-based namespaces must used characters that are legal in method names.</p>
<p>As a convenience to methods defined in a class-based namespace, the namespace
instance includes versions of several of the methods in the
<code class="xref py py-class docutils literal"><span class="pre">flask_socketio.SocketIO</span></code> class that default to the proper namespace
when the <code class="docutils literal"><span class="pre">namespace</span></code> argument is not given.</p>
<p>If an event has a handler in a class-based namespace, and also a
decorator-based function handler, only the decorated function handler is
invoked.</p>
</div>
<div class="section" id="error-handling">
<h2>Error Handling<a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h2>
<p>Flask-SocketIO can also deal with exceptions:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@socketio</span><span class="o">.</span><span class="n">on_error</span><span class="p">()</span>        <span class="c1"># Handles the default namespace</span>
<span class="k">def</span> <span class="nf">error_handler</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="nd">@socketio</span><span class="o">.</span><span class="n">on_error</span><span class="p">(</span><span class="s1">&#39;/chat&#39;</span><span class="p">)</span> <span class="c1"># handles the &#39;/chat&#39; namespace</span>
<span class="k">def</span> <span class="nf">error_handler_chat</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="nd">@socketio</span><span class="o">.</span><span class="n">on_error_default</span>  <span class="c1"># handles all namespaces without an explicit error handler</span>
<span class="k">def</span> <span class="nf">default_error_handler</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Error handler functions take the exception object as an argument.</p>
<p>The message and data arguments of the current request can also be inspected
with the <code class="docutils literal"><span class="pre">request.event</span></code> variable, which is useful for error logging and
debugging outside the event handler:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">request</span>

<span class="nd">@socketio</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="s2">&quot;my error event&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">on_my_event</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

<span class="nd">@socketio</span><span class="o">.</span><span class="n">on_error_default</span>
<span class="k">def</span> <span class="nf">default_error_handler</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">event</span><span class="p">[</span><span class="s2">&quot;message&quot;</span><span class="p">])</span> <span class="c1"># &quot;my error event&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">event</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">])</span>    <span class="c1"># (data,)</span>
</pre></div>
</div>
</div>
<div class="section" id="access-to-flask-s-context-globals">
<h2>Access to Flask&#8217;s Context Globals<a class="headerlink" href="#access-to-flask-s-context-globals" title="Permalink to this headline">¶</a></h2>
<p>Handlers for SocketIO events are different than handlers for routes and that
introduces a lot of confusion around what can and cannot be done in a SocketIO
handler. The main difference is that all the SocketIO events generated for a
client occur in the context of a single long running request.</p>
<p>In spite of the differences, Flask-SocketIO attempts to make working with
SocketIO event handlers easier by making the environment similar to that of a
regular HTTP request. The following list describes what works and what doesn&#8217;t:</p>
<ul class="simple">
<li>An application context is pushed before invoking an event handler making
<code class="docutils literal"><span class="pre">current_app</span></code> and <code class="docutils literal"><span class="pre">g</span></code> available to the handler.</li>
<li>A request context is also pushed before invoking a handler, also making
<code class="docutils literal"><span class="pre">request</span></code> and <code class="docutils literal"><span class="pre">session</span></code> available. But note that WebSocket events do not
have individual requests associated with them, so the request context that
started the connection is pushed for all the events that are dispatched
during the life of the connection.</li>
<li>The <code class="docutils literal"><span class="pre">request</span></code> context global is enhanced with a <code class="docutils literal"><span class="pre">sid</span></code> member that is set
to a unique session ID for the connection. This value is used as an initial
room where the client is added.</li>
<li>The <code class="docutils literal"><span class="pre">request</span></code> context global is enhanced with <code class="docutils literal"><span class="pre">namespace</span></code> and <code class="docutils literal"><span class="pre">event</span></code>
members that contain the currently handled namespace and event arguments.
The <code class="docutils literal"><span class="pre">event</span></code> member is a dictionary with <code class="docutils literal"><span class="pre">message</span></code> and <code class="docutils literal"><span class="pre">args</span></code> keys.</li>
<li>The <code class="docutils literal"><span class="pre">session</span></code> context global behaves in a different way than in regular
requests. A copy of the user session at the time the SocketIO connection is
established is made available to handlers invoked in the context of that
connection. If a SocketIO handler modifies the session, the modified session
will be preserved for future SocketIO handlers, but regular HTTP route
handlers will not see these changes. Effectively, when a SocketIO handler
modifies the session, a &#8220;fork&#8221; of the session is created exclusively for
these handlers. The technical reason for this limitation is that to save the
user session a cookie needs to be sent to the client, and that requires HTTP
request and response, which do not exist in a SocketIO connection. When
using server-side sessions such as those provided by the Flask-Session or
Flask-KVSession extensions, changes made to the session in HTTP route
handlers can be seen by SocketIO handlers, as long as the session is not
modified in the SocketIO handlers.</li>
<li>The <code class="docutils literal"><span class="pre">before_request</span></code> and <code class="docutils literal"><span class="pre">after_request</span></code> hooks are not invoked for
SocketIO event handlers.</li>
<li>SocketIO handlers can take custom decorators, but most Flask decorators will
not be appropriate to use for a SocketIO handler, given that there is no
concept of a <code class="docutils literal"><span class="pre">Response</span></code> object during a SocketIO connection.</li>
</ul>
</div>
<div class="section" id="authentication">
<h2>Authentication<a class="headerlink" href="#authentication" title="Permalink to this headline">¶</a></h2>
<p>A common need of applications is to validate the identify of their users. The
traditional mechanisms based on web forms and HTTP requests cannot be used in
a SocketIO connection, since there is no place to send HTTP requests and
responses. If necessary, an application can implement a customized login form
that sends credentials to the server as a SocketIO message when the submit
button is pressed by the user.</p>
<p>However, in most cases it is more convenient to perform the traditional
authentication process before the SocketIO connection is established. The
user&#8217;s identify can then be recorded in the user session or in a cookie, and
later when the SocketIO connection is established that information will be
accessible to SocketIO event handlers.</p>
<div class="section" id="using-flask-login-with-flask-socketio">
<h3>Using Flask-Login with Flask-SocketIO<a class="headerlink" href="#using-flask-login-with-flask-socketio" title="Permalink to this headline">¶</a></h3>
<p>Flask-SocketIO can access login information maintained by
<a class="reference external" href="https://flask-login.readthedocs.org/en/latest/">Flask-Login</a>. After a
regular Flask-Login authentication is performed and the <code class="docutils literal"><span class="pre">login_user()</span></code>
function is called to record the user in the user session, any SocketIO
connections will have access to the <code class="docutils literal"><span class="pre">current_user</span></code> context variable:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@socketio</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="s1">&#39;connect&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">connect_handler</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">current_user</span><span class="o">.</span><span class="n">is_authenticated</span><span class="p">:</span>
        <span class="n">emit</span><span class="p">(</span><span class="s1">&#39;my response&#39;</span><span class="p">,</span>
             <span class="p">{</span><span class="s1">&#39;message&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> has joined&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">current_user</span><span class="o">.</span><span class="n">name</span><span class="p">)},</span>
             <span class="n">broadcast</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># not allowed here</span>
</pre></div>
</div>
<p>Note that the <code class="docutils literal"><span class="pre">login_required</span></code> decorator cannot be used with SocketIO event
handlers, but a custom decorator that disconnects non-authenticated users can
be created as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">request</span>
<span class="kn">from</span> <span class="nn">flask_login</span> <span class="k">import</span> <span class="n">current_user</span>
<span class="kn">from</span> <span class="nn">flask_socketio</span> <span class="k">import</span> <span class="n">disconnect</span>

<span class="k">def</span> <span class="nf">authenticated_only</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">current_user</span><span class="o">.</span><span class="n">is_authenticated</span><span class="p">:</span>
            <span class="n">disconnect</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapped</span>

<span class="nd">@socketio</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="s1">&#39;my event&#39;</span><span class="p">)</span>
<span class="nd">@authenticated_only</span>
<span class="k">def</span> <span class="nf">handle_my_custom_event</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">emit</span><span class="p">(</span><span class="s1">&#39;my response&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;message&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> has joined&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">current_user</span><span class="o">.</span><span class="n">name</span><span class="p">)},</span>
         <span class="n">broadcast</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="deployment">
<h2>Deployment<a class="headerlink" href="#deployment" title="Permalink to this headline">¶</a></h2>
<p>There are many options to deploy a Flask-SocketIO server, ranging from simple
to the insanely complex. In this section, the most commonly used options are
described.</p>
<div class="section" id="embedded-server">
<h3>Embedded Server<a class="headerlink" href="#embedded-server" title="Permalink to this headline">¶</a></h3>
<p>The simplest deployment strategy is to have eventlet or gevent installed, and
start the web server by calling <code class="docutils literal"><span class="pre">socketio.run(app)</span></code> as shown in examples
above. This will run the application on the eventlet or gevent web servers,
whichever is installed.</p>
<p>Note that <code class="docutils literal"><span class="pre">socketio.run(app)</span></code> runs a production ready server when eventlet
or gevent are installed. If neither of these are installed, then the
application runs on Flask&#8217;s development web server, which is not appropriate
for production use.</p>
<p>Unfortunately this option is not available when using gevent with uWSGI. See
the uWSGI section below for information on this option.</p>
</div>
<div class="section" id="gunicorn-web-server">
<h3>Gunicorn Web Server<a class="headerlink" href="#gunicorn-web-server" title="Permalink to this headline">¶</a></h3>
<p>An alternative to <code class="docutils literal"><span class="pre">socketio.run(app)</span></code> is to use
<a class="reference external" href="http://gunicorn.org/">gunicorn</a> as web server, using the eventlet or gevent
workers. For this option, eventlet or gevent need to be installed, in addition
to gunicorn. The command line that starts the eventlet server via gunicorn is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">gunicorn</span> <span class="o">--</span><span class="n">worker</span><span class="o">-</span><span class="k">class</span> <span class="nc">eventlet</span> <span class="o">-</span><span class="n">w</span> <span class="mi">1</span> <span class="n">module</span><span class="p">:</span><span class="n">app</span>
</pre></div>
</div>
<p>If you prefer to use gevent, the command to start the server is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">gunicorn</span> <span class="o">-</span><span class="n">k</span> <span class="n">gevent</span> <span class="o">-</span><span class="n">w</span> <span class="mi">1</span> <span class="n">module</span><span class="p">:</span><span class="n">app</span>
</pre></div>
</div>
<p>When using gunicorn with the gevent worker and the WebSocket support provided
by gevent-websocket, the command that starts the server must be changed to
select a custom gevent web server that supports the WebSocket protocol. The
modified command is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">gunicorn</span> <span class="o">-</span><span class="n">k</span> <span class="n">geventwebsocket</span><span class="o">.</span><span class="n">gunicorn</span><span class="o">.</span><span class="n">workers</span><span class="o">.</span><span class="n">GeventWebSocketWorker</span> <span class="o">-</span><span class="n">w</span> <span class="mi">1</span> <span class="n">module</span><span class="p">:</span><span class="n">app</span>
</pre></div>
</div>
<p>In all these commands, <code class="docutils literal"><span class="pre">module</span></code> is the Python module or package that defines
the application instance, and <code class="docutils literal"><span class="pre">app</span></code> is the application instance itself.</p>
<p>Gunicorn release 18.0 is the recommended release to use with Flask-SocketIO.
The 19.x releases are known to have incompatibilities in certain deployment
scenarios that include WebSocket.</p>
<p>Due to the limited load balancing algorithm used by gunicorn, it is not possible
to use more than one worker process when using this web server. For that reason,
all the examples above include the <code class="docutils literal"><span class="pre">-w</span> <span class="pre">1</span></code> option.</p>
</div>
<div class="section" id="uwsgi-web-server">
<h3>uWSGI Web Server<a class="headerlink" href="#uwsgi-web-server" title="Permalink to this headline">¶</a></h3>
<p>When using the uWSGI server in combination with gevent, the Socket.IO server
can take advantage of uWSGI’s native WebSocket support.</p>
<p>A complete explanation of the configuration and usage of the uWSGI server is
beyond the scope of this documentation. The uWSGI server is a fairly complex
package that provides a large and comprehensive set of options. It must be
compiled with WebSocket and SSL support for the WebSocket transport to be
available. As way of an introduction, the following command starts a uWSGI
server for the example application app.py on port 5000:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ uwsgi --http :5000 --gevent 1000 --http-websockets --master --wsgi-file app.py --callable app
</pre></div>
</div>
</div>
<div class="section" id="using-nginx-as-a-websocket-reverse-proxy">
<h3>Using nginx as a WebSocket Reverse Proxy<a class="headerlink" href="#using-nginx-as-a-websocket-reverse-proxy" title="Permalink to this headline">¶</a></h3>
<p>It is possible to use nginx as a front-end reverse proxy that passes requests
to the application. However, only releases of nginx 1.4 and newer support
proxying of the WebSocket protocol. Below is a basic nginx configuration that
proxies HTTP and WebSocket requests:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>server {
    listen 80;
    server_name _;

    location / {
        include proxy_params;
        proxy_pass http://127.0.0.1:5000;
    }

    location /socket.io {
        include proxy_params;
        proxy_http_version 1.1;
        proxy_buffering off;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection &quot;Upgrade&quot;;
        proxy_pass http://127.0.0.1:5000/socket.io;
    }
}
</pre></div>
</div>
<p>The next example adds the support for load balancing multiple Socket.IO
servers:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>upstream socketio_nodes {
    ip_hash;

    server 127.0.0.1:5000;
    server 127.0.0.1:5001;
    server 127.0.0.1:5002;
    # to scale the app, just add more nodes here!
}

server {
    listen 80;
    server_name _;

    location / {
        include proxy_params;
        proxy_pass http://127.0.0.1:5000;
    }

    location /socket.io {
        include proxy_params;
        proxy_http_version 1.1;
        proxy_buffering off;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection &quot;Upgrade&quot;;
        proxy_pass http://socketio_nodes/socket.io;
    }
}
</pre></div>
</div>
<p>While the above examples can work as an initial configuration, be aware that a
production install of nginx will need a more complete configuration covering
other deployment aspects such as serving static file assets and SSL support.</p>
</div>
<div class="section" id="using-multiple-workers">
<h3>Using Multiple Workers<a class="headerlink" href="#using-multiple-workers" title="Permalink to this headline">¶</a></h3>
<p>Flask-SocketIO supports multiple workers behind a load balancer starting with
release 2.0. Deploying multiple workers gives applications that use
Flask-SocketIO the ability to spread the client connections among multiple
processes and hosts, and in this way scale to support very large numbers of
concurrent clients.</p>
<p>There are two requirements to use multiple Flask-SocketIO workers:</p>
<ul class="simple">
<li>The load balancer must be configured to forward all HTTP requests from a
given client always to the same worker. This is sometimes referenced as
&#8220;sticky sessions&#8221;. For nginx, use the <code class="docutils literal"><span class="pre">ip_hash</span></code> directive to achieve this.
Gunicorn cannot be used with multiple workers because its load balancer
algorithm does not support sticky sessions.</li>
<li>Since each of the servers owns only a subset of the client connections, a
message queue such as Redis or RabbitMQ is used by the servers to coordinate
complex operations such as broadcasting and rooms.</li>
</ul>
<p>When working with a message queue, there are additional dependencies that need to
be installed:</p>
<ul class="simple">
<li>For Redis, the package <code class="docutils literal"><span class="pre">redis</span></code> must be installed (<code class="docutils literal"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">redis</span></code>).</li>
<li>For RabbitMQ, the package <code class="docutils literal"><span class="pre">kombu</span></code> must be installed (<code class="docutils literal"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">kombu</span></code>).</li>
<li>For other message queues supported by Kombu, see the <a class="reference external" href="http://docs.celeryproject.org/projects/kombu/en/latest/introduction.html#transport-comparison">Kombu documentation</a>
to find out what dependencies are needed.</li>
<li>If eventlet or gevent are used, then monkey patching the Python standard
library is normally required to force the message queue package to use
coroutine friendly functions and classes.</li>
</ul>
<p>To start multiple Flask-SocketIO servers, you must first ensure you have the
message queue service running. To start a Socket.IO server and have it connect to
the message queue, add the <code class="docutils literal"><span class="pre">message_queue</span></code> argument to the <code class="docutils literal"><span class="pre">SocketIO</span></code>
constructor:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">socketio</span> <span class="o">=</span> <span class="n">SocketIO</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">message_queue</span><span class="o">=</span><span class="s1">&#39;redis://&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The value of the <code class="docutils literal"><span class="pre">message_queue</span></code> argument is the connection URL of the
queue service that is used. For a redis queue running on the same host as the
server, the <code class="docutils literal"><span class="pre">'redis://'</span></code> URL can be used. Likewise, for a default RabbitMQ
queue the <code class="docutils literal"><span class="pre">'amqp://'</span></code> URL can be used. The Kombu package has a <a class="reference external" href="http://docs.celeryproject.org/projects/kombu/en/latest/userguide/connections.html?highlight=urls#urls">documentation
section</a>
that describes the format of the URLs for all the supported queues.</p>
</div>
<div class="section" id="emitting-from-an-external-process">
<h3>Emitting from an External Process<a class="headerlink" href="#emitting-from-an-external-process" title="Permalink to this headline">¶</a></h3>
<p>For many types of applications, it is necessary to emit events from a process
that is not the SocketIO server, for a example a Celery worker. If the
SocketIO server or servers are configured to listen on a message queue as
shown in the previous section, then any other process can create its own
<code class="docutils literal"><span class="pre">SocketIO</span></code> instance and use it to emit events in the same way the server
does.</p>
<p>For example, for an application that runs on an eventlet web server and uses
a Redis message queue, the following Python script broadcasts an event to
all clients:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">socketio</span> <span class="o">=</span> <span class="n">SocketIO</span><span class="p">(</span><span class="n">message_queue</span><span class="o">=</span><span class="s1">&#39;redis://&#39;</span><span class="p">)</span>
<span class="n">socketio</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="s1">&#39;my event&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">},</span> <span class="n">namespace</span><span class="o">=</span><span class="s1">&#39;/test&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>When using the <code class="docutils literal"><span class="pre">SocketIO</span></code> instance in this way, the Flask application
instance is not passed to the constructor.</p>
<p>The <code class="docutils literal"><span class="pre">channel</span></code> argument to <code class="docutils literal"><span class="pre">SocketIO</span></code> can be used to select a specific
channel of communication through the message queue. Using a custom channel
name is necessary when there are multiple independent SocketIO services
sharing the same queue.</p>
<p>Flask-SocketIO does not apply monkey patching when eventlet or gevent are
used. But when working with a message queue, it is very likely that the Python
package that talks to the message queue service will hang if the Python
standard library is not monkey patched.</p>
<p>It is important to note that an external process that wants to connect to
a SocketIO server does not need to use eventlet or gevent like the main
server. Having a server use a coroutine framework, while an external process
does not is not a problem. For example, Celery workers do not need to be
configured to use eventlet or gevent just because the main server does. But if
your external process does use a coroutine framework for whatever reason, then
monkey patching is likely required, so that the message queue accesses
coroutine friendly functions and classes.</p>
</div>
<div class="section" id="upgrading-to-flask-socketio-1-x-and-2-x-from-the-0-x-releases">
<h3>Upgrading to Flask-SocketIO 1.x and 2.x from the 0.x releases<a class="headerlink" href="#upgrading-to-flask-socketio-1-x-and-2-x-from-the-0-x-releases" title="Permalink to this headline">¶</a></h3>
<p>Older versions of Flask-SocketIO had a completely different set of
requirements. Those old versions had a dependency on
<a class="reference external" href="https://gevent-socketio.readthedocs.org/en/latest/">gevent-socketio</a> and
<a class="reference external" href="https://pypi.python.org/pypi/gevent-websocket/">gevent-websocket</a>, which
are not required in release 1.0.</p>
<p>In spite of the change in dependencies, there aren&#8217;t many significant
changes introduced in version 1.0. Below is a detailed list of
the actual differences:</p>
<ul class="simple">
<li>Release 1.0 drops support for Python 2.6, and adds support for Python 3.3,
Python 3.4, and pypy.</li>
<li>Releases 0.x required an old version of the Socket.IO Javascript client.
Starting with release 1.0, the current releases of Socket.IO and Engine.IO
are supported. Releases of the Socket.IO client prior to 1.0 are no
supported. The Swift and C++ official Socket.IO clients are now supported
as well.</li>
<li>The 0.x releases depended on gevent, gevent-socketio and gevent-websocket.
In release 1.0 gevent-socketio is not used anymore, and gevent is one of
three options for backend web server, with eventlet and any regular
multi-threaded WSGI server, including Flask&#8217;s development web server.</li>
<li>The Socket.IO server options have changed in release 1.0. They can be
provided in the SocketIO constructor, or in the <code class="docutils literal"><span class="pre">run()</span></code> call. The options
provided in these two are merged before they are used.</li>
<li>The 0.x releases exposed the gevent-socketio connection as
<code class="docutils literal"><span class="pre">request.namespace</span></code>. In release 1.0 this is not available anymore. The
request object defines <code class="docutils literal"><span class="pre">request.namespace</span></code> as the name of the namespace
being handled, and adds <code class="docutils literal"><span class="pre">request.sid</span></code>, defined as the unique session ID
for the client connection, and <code class="docutils literal"><span class="pre">request.event</span></code>, which contains the event
name and arguments.</li>
<li>To get the list of rooms a client was in the 0.x release required the
application to use a private structure of gevent-socketio, with the
expression <code class="docutils literal"><span class="pre">request.namespace.rooms</span></code>. This is not available in release
1.0, which includes a proper <code class="docutils literal"><span class="pre">rooms()</span></code> function.</li>
<li>The recommended &#8220;trick&#8221; to send a message to an individual client was to
put each client in a separate room, then address messages to the desired
room. This was formalized in release 1.0, where clients are assigned a room
automatically when they connect.</li>
<li>The <code class="docutils literal"><span class="pre">'connect'</span></code> event for the global namespace did not fire on releases
prior to 1.0. This has been fixed and now this event fires as expected.</li>
<li>Support for client-side callbacks was introduced in release 1.0.</li>
</ul>
<p>To upgrade to the newer Flask-SocketIO releases, you need to upgrade your
Socket.IO client to a client that is compatible with the Socket.IO 1.0
protocol. For the JavaScript client, the 1.3.x and 1.4.x releases have been
extensively tested and found compatible.</p>
<p>On the server side, there are a few points to consider:</p>
<ul class="simple">
<li>If you wish to continue using gevent, then uninstall gevent-socketio from
your virtual environment, as this package is not used anymore and may
collide with its replacement, python-socketio.</li>
<li>If you want to have slightly better performance and stability, then it is
recommended that you switch to eventlet. To do this, uninstall gevent,
gevent-socketio and gevent-websocket, and install eventlet.</li>
<li>If your application uses monkey patching and you switched to eventlet, call
<cite>eventlet.monkey_patch()</cite> instead of gevent&#8217;s <cite>monkey.patch_all()</cite>. Also,
any calls to gevent must be replaced with equivalent calls to eventlet.</li>
<li>Any uses of <cite>request.namespace</cite> must be replaced with direct calls into the
Flask-SocketIO functions. For example, <cite>request.namespace.rooms</cite> must be
replaced with the <cite>rooms()</cite> function.</li>
<li>Any uses of internal gevent-socketio objects must be removed, as this
package is not a dependency anymore.</li>
</ul>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Welcome to ETLion Trade&#8217;s documentation!</a><ul>
<li><a class="reference internal" href="#installation">Installation</a></li>
<li><a class="reference internal" href="#requirements">Requirements</a></li>
<li><a class="reference internal" href="#initialization">Initialization</a></li>
<li><a class="reference internal" href="#receiving-messages">Receiving Messages</a></li>
<li><a class="reference internal" href="#sending-messages">Sending Messages</a></li>
<li><a class="reference internal" href="#broadcasting">Broadcasting</a></li>
<li><a class="reference internal" href="#rooms">Rooms</a></li>
<li><a class="reference internal" href="#connection-events">Connection Events</a></li>
<li><a class="reference internal" href="#class-based-namespaces">Class-Based Namespaces</a></li>
<li><a class="reference internal" href="#error-handling">Error Handling</a></li>
<li><a class="reference internal" href="#access-to-flask-s-context-globals">Access to Flask&#8217;s Context Globals</a></li>
<li><a class="reference internal" href="#authentication">Authentication</a><ul>
<li><a class="reference internal" href="#using-flask-login-with-flask-socketio">Using Flask-Login with Flask-SocketIO</a></li>
</ul>
</li>
<li><a class="reference internal" href="#deployment">Deployment</a><ul>
<li><a class="reference internal" href="#embedded-server">Embedded Server</a></li>
<li><a class="reference internal" href="#gunicorn-web-server">Gunicorn Web Server</a></li>
<li><a class="reference internal" href="#uwsgi-web-server">uWSGI Web Server</a></li>
<li><a class="reference internal" href="#using-nginx-as-a-websocket-reverse-proxy">Using nginx as a WebSocket Reverse Proxy</a></li>
<li><a class="reference internal" href="#using-multiple-workers">Using Multiple Workers</a></li>
<li><a class="reference internal" href="#emitting-from-an-external-process">Emitting from an External Process</a></li>
<li><a class="reference internal" href="#upgrading-to-flask-socketio-1-x-and-2-x-from-the-0-x-releases">Upgrading to Flask-SocketIO 1.x and 2.x from the 0.x releases</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, Chia-Hao Hsu.
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>

      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>
  </body>
</html>